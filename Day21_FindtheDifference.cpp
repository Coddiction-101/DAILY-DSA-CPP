/*
 * Problem: 389. Find the Difference (LeetCode)
 * Date: January 21, 2026
 * Difficulty: Easy
 * Topics: Strings, Hash Table, Bit Manipulation, Sorting
 * Time Complexity: O(n)
 * Space Complexity: O(1)
 * Problem Link: https://leetcode.com/problems/find-the-difference/
 *
 * Problem Statement:
 * You are given two strings s and t.
 * String t is generated by random shuffling string s and then adding one more letter
 * at a random position.
 * Return the letter that was added to t.
 *
 * Examples:
 *   Input:  s = "abcd", t = "abcde"
 *   Output: "e"
 *   Explanation: 'e' is the letter that was added.
 *
 *   Input:  s = "", t = "y"
 *   Output: "y"
 *
 *   Input:  s = "a", t = "aa"
 *   Output: "a"
 *
 * Key Insight:
 * We can use XOR bit manipulation property:
 *   - XOR of a number with itself is 0 (a ^ a = 0)
 *   - XOR of a number with 0 is the number itself (a ^ 0 = a)
 *   - XOR all characters from both strings, the extra character will remain
 * 
 * Alternative approaches:
 *   1. Sum of ASCII values: sum(t) - sum(s) = extra character
 *   2. Hash Map: count frequencies and find the extra one
 *   3. Sorting: sort both and find the mismatch
 */

#include <iostream>
#include <string>
using namespace std;

/*
 * Function: findTheDifference (Approach 1: XOR Bit Manipulation)
 * Purpose: Find the extra character added to string t using XOR.
 * Steps:
 *   1. Initialize result = 0
 *   2. XOR all characters from string s
 *   3. XOR all characters from string t
 *   4. The result will be the extra character (all pairs cancel out)
 * 
 * Why it works?
 *   - Every character in s appears in t (they cancel via XOR)
 *   - One extra character in t doesn't have a pair
 *   - XOR properties: a ^ a = 0, a ^ 0 = a
 *   - Time: O(n), Space: O(1) - optimal solution
 */
char findTheDifference_XOR(string s, string t) {
    char result = 0;  // Initialize with 0 (neutral element for XOR)
    
    // XOR all characters from s
    for (char c : s) {
        result ^= c;
    }
    
    // XOR all characters from t
    for (char c : t) {
        result ^= c;
    }
    
    // All matching characters cancel out, extra character remains
    return result;
}

/*
 * Function: findTheDifference_ASCII (Approach 2: Sum of ASCII values)
 * Purpose: Find the extra character by comparing ASCII value sums.
 * Steps:
 *   1. Calculate sum of all ASCII values in t
 *   2. Subtract sum of all ASCII values in s
 *   3. The difference is the ASCII value of the extra character
 * 
 * Why it works?
 *   - t has all characters from s plus one extra
 *   - sum(t) - sum(s) = ASCII value of extra character
 *   - Time: O(n), Space: O(1)
 */
char findTheDifference_ASCII(string s, string t) {
    int sum_s = 0;  // Sum of ASCII values in s
    int sum_t = 0;  // Sum of ASCII values in t
    
    // Calculate sum for s
    for (char c : s) {
        sum_s += c;
    }
    
    // Calculate sum for t
    for (char c : t) {
        sum_t += c;
    }
    
    // Return the character with ASCII value = difference
    return char(sum_t - sum_s);
}

/*
 * Function: findTheDifference_HashMap (Approach 3: Frequency Count)
 * Purpose: Find the extra character using hash map to count frequencies.
 * Steps:
 *   1. Create frequency map for string s
 *   2. For each character in t, decrement frequency
 *   3. The character with frequency != 0 is the extra one
 * 
 * Time: O(n), Space: O(26) = O(1) for lowercase English letters
 */
char findTheDifference_HashMap(string s, string t) {
    int freq[26] = {0};  // Frequency array for 'a' to 'z'
    
    // Count frequencies in s
    for (char c : s) {
        freq[c - 'a']++;
    }
    
    // Decrement frequencies using t
    for (char c : t) {
        freq[c - 'a']--;
        // If frequency becomes negative, this is the extra character
        if (freq[c - 'a'] < 0) {
            return c;
        }
    }
    
    return ' ';  // Should never reach here
}

// Main function for local testing
int main() {
    cout << "=== Day 21: Find the Difference ===" << endl;
    
    // Test Case 1: s = "abcd", t = "abcde"
    {
        string s = "abcd", t = "abcde";
        cout << "Test 1: s = \"" << s << "\", t = \"" << t << "\"" << endl;
        cout << "XOR Approach: " << findTheDifference_XOR(s, t) << " (expected: e)" << endl;
        cout << "ASCII Approach: " << findTheDifference_ASCII(s, t) << " (expected: e)" << endl;
        cout << "HashMap Approach: " << findTheDifference_HashMap(s, t) << " (expected: e)" << endl;
        cout << endl;
    }
    
    // Test Case 2: s = "", t = "y"
    {
        string s = "", t = "y";
        cout << "Test 2: s = \"" << s << "\", t = \"" << t << "\"" << endl;
        cout << "XOR Approach: " << findTheDifference_XOR(s, t) << " (expected: y)" << endl;
        cout << "ASCII Approach: " << findTheDifference_ASCII(s, t) << " (expected: y)" << endl;
        cout << "HashMap Approach: " << findTheDifference_HashMap(s, t) << " (expected: y)" << endl;
        cout << endl;
    }
    
    // Test Case 3: s = "a", t = "aa"
    {
        string s = "a", t = "aa";
        cout << "Test 3: s = \"" << s << "\", t = \"" << t << "\"" << endl;
        cout << "XOR Approach: " << findTheDifference_XOR(s, t) << " (expected: a)" << endl;
        cout << "ASCII Approach: " << findTheDifference_ASCII(s, t) << " (expected: a)" << endl;
        cout << "HashMap Approach: " << findTheDifference_HashMap(s, t) << " (expected: a)" << endl;
        cout << endl;
    }
    
    // Test Case 4: s = "ae", t = "aea"
    {
        string s = "ae", t = "aea";
        cout << "Test 4: s = \"" << s << "\", t = \"" << t << "\"" << endl;
        cout << "XOR Approach: " << findTheDifference_XOR(s, t) << " (expected: a)" << endl;
        cout << "ASCII Approach: " << findTheDifference_ASCII(s, t) << " (expected: a)" << endl;
        cout << "HashMap Approach: " << findTheDifference_HashMap(s, t) << " (expected: a)" << endl;
        cout << endl;
    }
    
    return 0;
}

/*
 * Dry Run Example (XOR Approach):
 * Input: s = "abcd", t = "abcde"
 * 
 * Initial: result = 0
 * 
 * XOR characters from s:
 *   result ^= 'a' → 0 ^ 97 = 97
 *   result ^= 'b' → 97 ^ 98 = 3
 *   result ^= 'c' → 3 ^ 99 = 96
 *   result ^= 'd' → 96 ^ 100 = 4
 * 
 * XOR characters from t:
 *   result ^= 'a' → 4 ^ 97 = 101 (cancels with 'a' from s)
 *   result ^= 'b' → 101 ^ 98 = 7 (cancels with 'b' from s)
 *   result ^= 'c' → 7 ^ 99 = 100 (cancels with 'c' from s)
 *   result ^= 'd' → 100 ^ 100 = 0 (cancels with 'd' from s)
 *   result ^= 'e' → 0 ^ 101 = 101
 * 
 * Final: result = 101 = 'e' ✓
 * 
 * Actually, the XOR operations work because:
 * (a ^ b ^ c ^ d) ^ (a ^ b ^ c ^ d ^ e) = e
 * All matching characters cancel out, leaving only 'e'
 * 
 * Key Points:
 * - XOR is the most elegant: O(n) time, O(1) space
 * - ASCII sum is intuitive: O(n) time, O(1) space
 * - HashMap is straightforward: O(n) time, O(1) space
 * - All three approaches work, XOR is most efficient in practice
 */
